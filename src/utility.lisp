(in-package #:cl-99)

(defmacro with-gensyms ((&rest names) &body body)
  "Generates a globally unique symbol then executes the body."
  `(let ,(loop for n in names collect `(,n (gensym)))
     ,@body))

(defmacro once-only ((&rest names) &body body)
  "Generates macro that loads the input symbols only once."
  (let ((syms (loop for name in names collect (gensym))))
    `(let (,@(loop for sym in syms collect `(,sym (gensym))))
       `(let (,,@(loop for sym in syms for name in names collect ``(,,sym ,,name))) 
          ,(let (,@(loop for name in names for sym in syms collect `(,name ,sym))) 
             ,@body)))))

(defmacro execute-macro (macro-name &rest args)
  "Execute the macro generated by the macro that generates macro."
  (with-gensyms (new-macro)
    `(progn
       (defmacro ,new-macro ()
         (,macro-name ,@args))
       (,new-macro))))

(defun duplicate (cnt elem)
  "Generates a list which contains <cnt> duplications of <elem>."
  (loop repeat cnt collect elem))

(defun operate-on-consecutive-duplicates (lst init-func aggr-func)
  "perform operations on consecutive duplicates in the given list
   init-func takes a non-nil list and returns the initial value to aggregate
   aggr-func takes two arguments in which the first one is the result 
        previously generated, and the second one is to be aggregated"
  (if (null lst) 
    nil
    (nreverse (reduce aggr-func
                      (rest lst) ;avoid case like (list nil)
                      :initial-value (funcall init-func lst)))))

(defun join (func lst)
  "applies <func> on each element of <lst> and join the result lists to a single one"
  (reduce #'append (mapcar func lst)))

(defun symbol-function-or-nil (symbol)
  (if (and (fboundp symbol)
           (not (macro-function symbol))
           (not (special-operator-p symbol)))
    (symbol-function symbol)
    nil))
